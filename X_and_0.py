str_all_step = '' #задается переменная типа строка для проверки ввода одинаковых ходов
dict_game = {} #Задается словарь для записи игроков и их символов
count_step1 = 0 # задается счетчик хода для игрока 1
count_step2 = 0 # задается счетчик кода для игрока 2
gamer_name1 = '' # задется переменная типа строка для хранения имени игрока 1
gamer_name2 = '' # задается переменная типа строка для хранения имени игрока 2


def welcome(): #задается ф-ция для приветствия и начального этапа игры
    global game_values, str_all_step, str_all_step, dict_game, count_step1, count_step2, gamer_name1, gamer_name2 #говорим отом ,
    # что будем работать и изменять глобальный переменные, что бы при вызове фун-ции они обнулялись
    str_all_step = ''
    dict_game = {}
    count_step1 = 0
    count_step2 = 0
    gamer_name1 = ''
    gamer_name2 = ''
    game_values = [[' ', 1, 2, 3], [1, '-', '-', '-'], [2, '-', '-', '-'], [3, '-', '-', '-']] # вводим игровое поле, заполняя его пустыми символами ввиде
    print('''               Добрый день!
            Вы находитесь в игре "Крестики-Нолики". Ваша задача, договарившись с соперником,
            кто какими символами будет играть:
            один игрок играет за крестики, второй за нолики(Х или 0).
            Цель игры поставить свои символы в ячейки так,
            чтобы получилась целая линия: вертикальная, горизонтальная или по диагонали.
            Тот, кто совершит это первым- выиграл!''') #Вывод приветственного сообщения и правила игры

    gamers_and_choice() #вызов переменной для ввода имен игроков и символов. которыми они будут играть


def gamers_and_choice(): #задется ф-ция для ввода имен игроков и символов
    global dict_game, gamer_name1, gamer_name2 #в этой ф-ции будем изменять данные переменные
    while True: #бесконечный цикл нужен для повтора действий при некорректном вводе параметров
        gamer_name1 = input('Введите имя первого игрока: ') #имя первого игрока
        choice1 = input('Введите символ, которым будете играть: ').upper() #символ,которым он будет играть
        gamer_name2 = input('Введите имя второго игрока: ') #имя второго игрока

        if any([all([choice1 != '0', choice1 != 'X', choice1 != 'Х']), gamer_name1.upper() == gamer_name2.upper(),
                any([not gamer_name1.isalpha(), not gamer_name2.isalpha()])]): #проверка на правильность ввода символов и имен
            print(
                'Введите верный символ (Х/0) или имена игроков не отличаются или полностью состоят из цифр. Давайте еще раз.')
            continue

        elif choice1 == 'X' or choice1 == 'Х': #если символы введены верно заполняем словарь ключами в виде имен и значениями в виде символов
            dict_game[gamer_name1] = 'X'
            dict_game[gamer_name2] = '0'
            break
        else:
            dict_game[gamer_name1] = '0'
            dict_game[gamer_name2] = 'X'
            break

def menu(): #вводим ф-цию меню, для общения с игроками
    while True: #бесконечный цикл для повтора ввода значений при некорректном вводе пунктов меню
        print(f'''           --МЕНЮ--
        для игрока {gamer_name1} и игрока {gamer_name2}
    1. Посмотреть карту игры
    2. Начать/Продолжить ходить
    3. Начать заново 
    4. Выйти из игры 
    ''')
        n = '' #переменная, хранящая то, что ф-ция будет возвращать
        button = input('Введите пункт меню:') #ввод выбора пункта из меню
        if button == '1':
            playing_field(game_values) #вызов функции, для демонстрации игрового поля
            break
        elif button == '2':
            break
        elif button == '3':
            n = 'True'
            break
        elif button == '4':
            n = 'False'
            break
        else:
            continue
    return n


def playing_field(lst): #ф-ция для демонстрации игрового поля
    str_filed = '' #строка для записи в нее элементов списка игрового поля
    print('==КАРТА ИГРЫ==')
    for column in range(len(lst)):
        for line in lst[column]:        #вложенный цикл для поэлементного перебора вложенного списка игрового поля
            str_filed += f' {line} ' # записываем каждый элемент в строку
        print(f'{str_filed}') # ввыдом строку
        str_filed = '' # как только элементы во вложенном списке игрового поля, отвечающие за строку закончились,
        # переходим на след. строку, для этого обнуляем переменную строки


def gamer1(): #ф-ция описывающая ход игрока 1
    n = '' #переменная для хранения значения, которое функция будет возвращать

    global count_step1, str_all_step #будем изменять глобальные данные переменные
    while True: # бесконечный цикл, для повтора действий при некорректном вводе
        print(f'ходит игрок {gamer_name1}')
        column1 = input("введите позицию сверху-вниз (от 1 до 3): ") #записываем позицию по вертикале
        line1 = input("Введите позицию слева-направо  (от 1 до 3): ") #записываем позицию горизонтале
        if column1 in ['1', '2', '3'] and line1 in ['1', '2', '3']: #проверка корректности ввода
            if column1 + line1 in str_all_step: #проверка по заятой позиции
                print("Эта позиция уже занята. Попробуйте ещe раз.")
                continue
            else:
                count_step1 += 1 #если проверка прошла, увеличиваем шаг
                str_all_step += f'Ход № {count_step1}\nХодил игрок - {gamer_name1}\n=={column1 + line1}==\n___________________\n'
                #записываем в строку результат хода и другую информацию для вывода истории ходов
                game_values[int(column1)][int(line1)] = dict_game[gamer_name1] #перезаписываем значение в список игрового
                # поля по введенным координатам элемент берем из словаря с именами и занчениями

                if count_step1 >= 3: #проверка счетчика шагов игрока 1, как только он станет равным 3
                    if game_check(game_values): # мы вызываем функцию проверки и сразу же проверяем возвращение этой функции
                        n = "True"
                        break
                    else: #если функция ничего не вернула, значит игрок 1 пока не победил
                        # и мы выходим из бесконечного цикла и заканчиваем работу данной функции
                        break
                else: # если счетчик меньше 3, то нам незачем пока проверять на выигрыш игрока 1,
                    # мы выходим из бесконечного цикла и заканчиваем работу данной функции
                    break
        else: #если проверка не пройдена, то начинаем сначала
            print("Неверные значения, попробуйте еще раз")
            continue
    return n


def gamer2(): #задаем такую же функцию для игрока 2, тут все то же самое, только переменные имеют название с 2-ой в конце
    n = ''
    while True:
        global count_step2, str_all_step
        print(f'ходит игрок {gamer_name2}')
        column2 = input("введите позицию сверху-вниз (от 1 до 3): ")
        line2 = input("Введите позицию слева-направо (от 1 до 3): ")
        if column2 in ['1', '2', '3'] and line2 in ['1', '2', '3']:
            if column2 + line2 in str_all_step:
                print("Эта позиция уже занята. Попробуйте ещe раз.")
                continue
            else:
                count_step2 += 1
                str_all_step += f'Ход № {count_step2}\nХодил игрок - {gamer_name2}\n=={column2 + line2}==\n___________________\n'
                game_values[int(column2)][int(line2)] = dict_game[gamer_name2]

                if count_step2 >= 3:
                    if game_check(game_values):
                        n = "True"
                        break
                    else:
                        break
                else:
                    break
        else:
            print("Неверные значения, попробуйте еще раз")
            continue
    return n


def game_check(lst): #ф-ция проверки на выигрыш
    lst_ = [] #создаем пустой список,в который будем записывать только данные списка игрового поля
    for i in range(1, 4):
        lst_.extend(lst[i][1:]) #для этого бежим по списку игрового поля начиная со второго индекса,
        # так как на первых позиция находятся оси координат. Записываем все строку сразу опять же начиная со второго элемента
    if ('-' not in lst_[0:3:1]) or ('-' not in lst_[3:6:1]) or ('-' not in lst_[6:9:1]): # проверка на заполненность каой-либо строки символами игроков
        if len(set(lst_[0:3:1])) == 1: #проверка на то, что в 1ой строке все символы одинаковы
            if dict_game[list(dict_game.keys())[0]] == lst_[0]: #проверка на то, что эти символы принадлежат игроку 1
                print(f'Победа за игроком - {list(dict_game.keys())[0]}!!!')
                return 'True'
            elif dict_game[list(dict_game.keys())[1]] == lst_[0]: #проверка на то, что все символы принадлежат игроку 2
                print(f'Победа за игроком - {list(dict_game.keys())[1]}!!!')
                return 'True'

        if len(set(lst_[3:6:1])) == 1: #проверка на то, что в 2ой строке все символы одинаковы
            if dict_game[list(dict_game.keys())[0]] == lst_[3]:
                print(f'Победа за игроком - {list(dict_game.keys())[0]}!!!')
                return 'True'
            elif dict_game[list(dict_game.keys())[1]] == lst_[3]:
                print(f'Победа за игроком - {list(dict_game.keys())[1]}!!!')
                return 'True'

        if len(set(lst_[6:9:1])) == 1:#проверка на то, что в 3ей строке все символы одинаковы
            if dict_game[list(dict_game.keys())[0]] == lst_[6]:
                print(f'Победа за игроком - {list(dict_game.keys())[0]}!!!')
                return 'True'
            elif dict_game[list(dict_game.keys())[1]] == lst_[6]:
                print(f'Победа за игроком - {list(dict_game.keys())[1]}!!!')
                return 'True'

    if ('-' not in lst_[0:7:3]) or ('-' not in lst_[1:8:3]) or ('-' not in lst_[2:9:3]):# проверка на заполненность одного из столбцов символами игроков
        if len(set(lst_[0:7:3])) == 1: #проверка на то, что в 1ом столбце все символы одинаковы
            if dict_game[list(dict_game.keys())[0]] == lst_[0]:
                print(f'Победа за игроком - {list(dict_game.keys())[0]}!!!')
                return 'True'
            elif dict_game[list(dict_game.keys())[1]] == lst_[0]:
                print(f'Победа за игроком - {list(dict_game.keys())[1]}!!!')
                return 'True'

        if len(set(lst_[1:8:3])) == 1: #проверка на то, что в 2ом столбце все символы одинаковы
            if dict_game[list(dict_game.keys())[0]] == lst_[1]:
                print(f'Победа за игроком - {list(dict_game.keys())[0]}!!!')
                return 'True'
            elif dict_game[list(dict_game.keys())[1]] == lst_[1]:
                print(f'Победа за игроком - {list(dict_game.keys())[1]}!!!')
                return 'True'

        if len(set(lst_[2:9:3])) == 1: #проверка на то, что в 3ьем столбце все символы одинаковы
            if dict_game[list(dict_game.keys())[0]] == lst_[2]:
                print(f'Победа за игроком - {list(dict_game.keys())[0]}!!!')
                return 'True'
            elif dict_game[list(dict_game.keys())[1]] == lst_[2]:
                print(f'Победа за игроком - {list(dict_game.keys())[1]}!!!')
                return 'True'

    if ('-' not in lst_[0:9:4]) or ('-' not in lst_[2:7:2]): # проверка на заполненность одной из диагоналей символами игроков
        if len(set(lst_[0:9:4])) == 1: #проверка на то, что в 1ой диагонали все символы одинаковы
            if dict_game[list(dict_game.keys())[0]] == lst_[0]:
                print(f'Победа за игроком - {list(dict_game.keys())[0]}!!!')
                return 'True'
            elif dict_game[list(dict_game.keys())[1]] == lst_[0]:
                print(f'Победа за игроком - {list(dict_game.keys())[1]}!!!')
                return 'True'

        if len(set(lst_[2:7:2])) == 1: #проверка на то, что в 1ой диагонали все символы одинаковы
            if dict_game[list(dict_game.keys())[0]] == lst_[2]:
                print(f'Победа за игроком - {list(dict_game.keys())[0]}!!!')
                return 'True'
            elif dict_game[list(dict_game.keys())[1]] == lst_[2]:
                print(f'Победа за игроком - {list(dict_game.keys())[1]}!!!')
                return 'True'

    if len(set(lst_)) == 2: # проверка на заполненность всего поля символами игроков
        print('Ничья!!!')
        return 'True'


def menu_continue(): # ф-ция меню после выигрыша одного из игроков или ничьей
    while True: #  # мой любимый бесконечный цикл на случай криворукости пользователей
        print(f'''           --МЕНЮ--
        для игрока {gamer_name1} и игрока {gamer_name2}
    1. Посмотреть карту игры
    2. Посмотреть историю ходов
    3. Начать заново 
    4. Выйти из игры 
    ''')
        n = '' # моя любимая переменная, которая хранит в себе данные вывода функции
        button = input('Введите пункт меню:')
        if button == '1':
            playing_field(game_values)
            continue
        #    break
        elif button == '2':
            print(f'===История ходов===\n{str_all_step}')
            continue
        #    break
        elif button == '3':
            n = 'True'
            break
        elif button == '4':
            n = 'False'
            break
        else:
            continue
    return n


def game(): # ф-ция игры (основная функция)
    welcome() # запуск ф-ции приветствия
    while True:# бесконечный цикл, в конкретном случае, предстал в непривычном для нас амплуа, он здесь для того,
    # что бы пользователи могли наслаждаться игрой бесконечно. Ну и еще для того, что бы правильно отрабатывал пункт меню, если пользователь захочет выйти из игры
        k = menu() # записываем в переменную к результат возвращения после отработки ф-ции меню
        if k == 'False':
            ex = 0 # переменная, значение которую будет возвращать данная функция (n уже надоела)
            break
        elif k == 'True':
            ex = 1
            break
        n = gamer1() # записываем в переменную n результат возвращения после отработки ф-ции хода игрока 1
        if n == "True":
            ex = 1
            k = menu_continue() # записываем в переменную к результат возвращения после отработки ф-ции конечного меню
            if k == 'False':
                ex = 0
                break
            elif k == 'True':
                ex = 1
                break
            break
        k = menu()
        if k == 'False':
            ex = 0
            break
        elif k == 'True':
            ex = 1
            break
        n = gamer2() # записываем в переменную n результат возвращения после отработки ф-ции хода игрока 1
        if n == "True":
            ex = 1
            k = menu_continue()
            if k == 'False':
                ex = 0
                break
            elif k == 'True':
                ex = 1
                break
            break

    return ex


while True: # бесконечный цикл, в конкретном случае, предстал в непривычном для нас амплуа, он здесь для того,
    # что бы пользователи могли наслаждаться игрой бесконечно. Ну и еще для того, что бы правильно отрабатывал пункт меню, если пользователь захочет выйти из игры
    n = game()
    if n == 0:
        break
    elif n == 1:
        continue
